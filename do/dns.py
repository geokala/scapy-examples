#! /usr/bin/env python
# scapy.all is generated dynamically, stop pylint complaining.
# pylint: disable=E1101
"""
    Example of generating a DNS request.
"""
from __future__ import print_function

import argparse
import socket
from sys import stderr, exit

import netifaces

# If we don't get all of scapy, packet types are not identified and we end
# up losing a lot of the usefulness.
import scapy.all as scapy

from arp import arp_query


class BadQuery(Exception):
    pass


def make_dns_query(qname, qtype, resolver_ip, src_ip,
                   gateway_mac, src_mac):
    if qtype not in scapy.DNSQR.qtype.s2i.keys():
        raise BadQuery(
            'Query type must be one of: {types}'.format(
                types=', '.join(scapy.DNSQR.qtype.s2i.keys()),
            )
        )

    ether = scapy.Ether(
        src=src_mac,
        dst=gateway_mac,
        type='IPv4',
    )

    # Not setting values such as source IP, etc, will cause them to be
    # generated by scapy
    ip = scapy.IP(
        src=src_ip,
        dst=resolver_ip,
        version=4,
        proto='udp',
    )

    # As we don't set the UDP source port it will be randomised
    udp = scapy.UDP(
        dport=53,
    )

    dns = scapy.DNS(
        id=404, # Arbitrary ID used to match DNS responses to requests
        qr=0, # Query(0)/response(1)
        opcode=0, # Operation
                  # 0 = Standard query
                  # 1 = Inverse query (obsolete)
                  # 2 = Server status request
                  # 3 = Reserved ,not used
                  # 4 = Notification that zone transfer is required
                  # 5 = Update, for dynamic DNS
        aa=0, # Is this an authoritative answer? 1 for yes, 0 for no
        tc=0, # Is message truncated? 1 for yes, 0 for no
        rd=1, # Recursion desired? 1 for yes, 0 for no
        ra=0, # Recursion available (sent by server) 1 for yes, 0 for no
        z=0, # Reserved bits, not used
        ad=0, # Authenticated data, 1 if the answer has been verified by the
              # server, e.g. using DNSSEC
        cd=0, # Checking disabled, 1 to disable signature verification on
              # responses (DNSSEC)
        rcode=0, # Response code:
                 # 0 = No error
                 # 1 = Server could not respond to query due to how it was
                 #     constructed
                 # 2 = Server could not respond to query due to internal error
                 # 3 = Name error- name does not exist in domain
                 # 4 = Type of query not supported by server
                 # 5 = Server refused to process query for policy reasons
                 # 6 = Name exists that should not
                 # 7 = Resource record set exists that should not
                 # 8 = Resource record set does not exist that should
                 # 9 = Server receiving query is not authoritative
                 # 10 = Name specified in query is not in zone specified in
                 #      query
        qdcount=1, # Query count
        ancount=0, # Answer count
        nscount=0, # Nameserver count
        arcount=0, # Additional record count
    )

    query = scapy.DNSQR(
        qname=qname,
        qtype=qtype,
        qclass='IN',  # Internet
    )

    return ether / ip / udp / dns/ query


def dns_hostname_query(hostname, resolver_ip):
    # This returns (<IP>, <interface>)
    default_gateway_ip, default_gateway_interface = \
        netifaces.gateways()['default'][netifaces.AF_INET]
    default_gateway_arp = arp_query(
        destination=default_gateway_ip,
        interface=default_gateway_interface,
    )

    src_mac = netifaces.ifaddresses(
        default_gateway_interface,
    )[netifaces.AF_LINK][0]['addr']

    src_ip = netifaces.ifaddresses(
        default_gateway_interface,
    )[netifaces.AF_INET][0]['addr']

    packet = make_dns_query(
        hostname,
        'A',
        resolver_ip,
        src_ip=src_ip,
        gateway_mac=default_gateway_arp.hwsrc,
        src_mac=src_mac,
    )

    try:
        result = scapy.srp1(packet, timeout=5,
                            iface=default_gateway_interface)
    except socket.error as err:
        if 'No such device' in err:
            stderr.write(
                'Could not use device {interface} as it does not appear '
                'to exist.'.format(
                    interface=interface,
                )
            )
            exit(1)
        print(err)
        raise

    if not result:
        stderr.write(
            'No response for A query to {ip} for hostname '
            '{hostname} was received.'.format(
                ip=resolver_ip,
                hostname=hostname,
            )
        )
        result = None

    return result


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Perform a DNS query.',
    )

    parser.add_argument(
        '-H', '--hostname',
        help='Hostname to query',
        required=True,
    )
    parser.add_argument(
        '-r', '--resolver-ip',
        help='DNS server (resolver) to use',
        required=True,
    )

    args = parser.parse_args()

    result = dns_hostname_query(
        hostname=args.hostname,
        resolver_ip=args.resolver_ip,
    )

    if result is None:
        stderr.write(
            'Failed to get result.\n'
        )
        exit(1)
    else:
        print(result.summary())
